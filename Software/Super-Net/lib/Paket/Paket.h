#ifndef PAKET_H
#define PAKET_H
#include <string>
#include <map>
#include <vector>
#include <userdata.h>

//#define PACKETDEBUG
/**
 * @file Paket.h
general packet-structure:
  ================================================================
|| recipient | referenceid | type      | size      | payload	  ||
  ================================================================

  recipient: INTEGER            |  0 = broadcast
  referenceid: INTEGER
  type: BYTE(CHAR)
  size: INTEGER [OPTIONAL]
  payload: CHAR* (bytearray)  [OPTIONAL]

  It's possible to stack a packet into another one.

  ==============================================================================================

  FORWARD-packet:

  <recipient> <referenceid> <forward-byte-code> <size of forwarded packet> <packet to forward>
	
	--> forwarded packet can also be another forward packet, so that way it is possible
		to send the packet over a predefined route.

		SIZE: 3*INTEGER + 1 + forward_packet_size

  ==============================================================================================

  ACK-packet:

  <recipient> <referenceid> <ACK-byte-code>
	
	--> through the reference id the recipient of this packet is assured, that his message 
		arrived at its destination

		SIZE: 2*INTEGER + 1

  ==============================================================================================

  WHOHAS-packet:

  <recipient = 0> <referenceid> <WHOHAS-byte-code> <maximum hops [INTEGER]> <address of the wanted client [INTEGER]>

	--> repeated by everyone who receives this. the referenceid assures that a packet isn't
		repeated twice by the same client.

	maximum hops: maximum count of hops to destination

		SIZE: 4*INTEGER + 1

  ==============================================================================================

  IHAVE-packet:

  <recipient> <referenceid> <IHAVE-byte-code> <maximum hops> <ihave_grid_size> <ihavegrid>

	--> this packet is the answer to the WHOHAS packet and contains an ihavegrid.

	ihavegrid:
		contains a possible network route (consisting of hops) to the desired client.
		a hop is defined by its address and reachability(signal strength).

	maximum hops:	maximum count of hops in this possible route, if a node gets an ihave packet
					it only add itself to the ihavegrid and forwards the packet if the ihave grid
					doesnt already have the maximum count of hops and also doesn't contain this
					node yet.. that garantees that ihave packets
					dont circle in the aether forever since they are broadcasted and reproduced
	
	if several IHAVE-packets are received the best route can be determined using the hop-data
	of every single hop.

		SIZE: 3*INTEGER + 1 + gridsize


  ==============================================================================================

  MSG-packet:

  <recipient> <referenceid> <MSG-byte-code> <routesize> <used route> <payloadsize> <payload>

  routesize: INTEGER               | number of bytes, not hops
  used route: INTEGER[]
	--> the route should also contain the sender adress so that the ack can be directed
		
		SIZE: 4*INTEGER + 1 + routesize + payloadsize
  
  ==============================================================================================

  typebytes:
	 0 - whohas <br>
	 1 - ihave<br>
	 2 - msg<br>
	 3 - ACK <br>
	 4 - forward<br>
 */

using namespace std;

/// <summary>
/// represents one Network-hop
/// </summary>
class hop {
public:
	/// <summary>
	/// the Node-ID of this hop
	/// </summary>
	unsigned int id;
	/// <summary>
	/// The Signalstrength to the last hop
	/// </summary>
	int rssi;
	/// <summary>
	/// Constructor - generates a Super-Net hop
	/// </summary>
	/// <param name="id">the Node-ID of the hop</param>
	/// <param name="rssi">the signalstrength to the previous hop</param>
	hop(unsigned int id, int rssi);
};

/// <summary>
/// Class with static functions for basic byteoperations and Conversions
/// </summary>
class bytes {
public:
	/// <summary>
	/// creates a byte array representing an integer
	/// </summary>
	/// <param name="in">the int thats supposed to be converted to a bytearray</param>
	/// <returns>the generated bytearray</returns>
	static char* int2bytes(int in);
	/// <summary>
	/// parses an Integer from a bytearray
	/// </summary>
	/// <param name="in">the bytearray from which should be parsed</param>
	/// <param name="startindex">the position of the integer in the bytearray</param>
	/// <returns>the parsed inteer</returns>
	static int bytes2int(char* in, int startindex=0);
	/// <summary>
	/// copies bytes from one bytearray to another
	/// </summary>
	/// <param name="src">source bytearray</param>
	/// <param name="dest">destination bytearray</param>
	/// <param name="startsrc">startposition in sourcearray</param>
	/// <param name="startdest">startposition in destinationarray</param>
	/// <param name="count">amount of copied bytes</param>
	static void bytecopy(char* src, char* dest, int startsrc, int startdest, int count);
};

/// <summary>
/// represents an ihave grid which is part of an ihave-packet
/// it Contains hops in an order which can be use as a route for packets
/// </summary>
class ihave_grid {
public:
	/// <summary>
	/// adds a Super-Net hop to the ihave_grid
	/// </summary>
	/// <param name="h">the hop to be added</param>
	void add_hop(hop h);

	/// <summary>
	/// converts this object to a bytearray
	/// </summary>
	/// <returns></returns>
	char* tobytes();

	/// <summary>
	/// returns the size in bytes of this object when converted to a bytearray
	/// </summary>
	/// <returns>the size in bytes</returns>
	int bytecount();

	/// <summary>
	/// returns the maximum Rssi value the hops in this ihavegrid have
	/// ->the bigger the value, the weaker the signal ->
	/// </summary>
	/// <returns>the maximum Rssi value of the contained hops</returns>
	int max_rssi();

	/// <summary>
	/// checks if this ihavegrid already contains a hop with the specified id
	/// </summary>
	/// <param name="id">super-net hop id</param>
	/// <returns>true if contains a hop with the id, false if not</returns>
	bool contains_id(int id);

	/// <summary>
	/// returns a route(represented by an vector of ints) containing the adresses of the
	/// hops of this ihavegrid
	/// </summary>
	/// <returns>the route vector</returns>
	vector<int> * create_route();
	#ifdef PACKETDEBUG
	void print();
	#endif
private:
	/// <summary>
	/// vector of the super-net hops contained by this ihavegrid
	/// </summary>
	vector<hop> hops;
	/// <summary>
	/// see void bytecount()
	/// </summary>
	int _bytecount = 0;
};



/*
general packet-structure:
  ================================================================
|| recipient | referenceid | type      | size      | payload	  ||
  ================================================================

  recipient: INTEGER            |  0 = broadcast
  referenceid: INTEGER
  type: BYTE(CHAR)
  size: INTEGER [OPTIONAL]
  payload: CHAR* (bytearray)  [OPTIONAL]

  It's possible to stack a packet into another one.

  ==============================================================================================

  FORWARD-packet:

  <recipient> <referenceid> <forward-byte-code> <size of forwarded packet> <packet to forward>
	
	--> forwarded packet can also be another forward packet, so that way it is possible
		to send the packet over a predefined route.

		SIZE: 3*INTEGER + 1 + forward_packet_size

  ==============================================================================================

  ACK-packet:

  <recipient> <referenceid> <ACK-byte-code>
	--> through the reference id the recipient of this packet is assured, that his message 
		arrived at its destination

		SIZE: 2*INTEGER + 1

  ==============================================================================================

  WHOHAS-packet:

  <recipient = 0> <referenceid> <WHOHAS-byte-code> <maximum hops [INTEGER]> <address of the wanted client [INTEGER]>

	--> repeated by everyone who receives this. the referenceid assures that a packet isn't
		repeated twice by the same client.

	maximum hops: maximum count of hops to destination
	SIZE: 4*INTEGER + 1

  ==============================================================================================

  IHAVE-packet:

  <recipient> <referenceid> <IHAVE-byte-code> <maximum hops> <ihave_grid_size> <ihavegrid>

	--> this packet is the answer to the WHOHAS packet and contains an ihavegrid.

	ihavegrid:
		contains a possible network route (consisting of hops) to the desired client.
		a hop is defined by its address and reachability(signal strength).

	maximum hops:	maximum count of hops in this possible route, if a node gets an ihave packet
					it only add itself to the ihavegrid and forwards the packet if the ihave grid
					doesnt already have the maximum count of hops and also doesn't contain this
					node yet.. that garantees that ihave packets
					dont circle in the aether forever since they are broadcasted and reproduced
	
	if several IHAVE-packets are received the best route can be determined using the hop-data
	of every single hop.

	SIZE: 3*INTEGER + 1 + gridsize


  ==============================================================================================

  MSG-packet:

  <recipient> <referenceid> <MSG-byte-code> <routesize> <used route> <payloadsize> <payload>

  routesize: INTEGER               | number of bytes, not hops
  used route: INTEGER[]
	--> the route should also contain the sender adress so that the ack can be directed
		
		SIZE: 4*INTEGER + 1 + routesize + payloadsize
  
  ==============================================================================================

  typebytes:
	 0 - whohas
	 1 - ihave
	 2 - msg
	 3 - ACK 
	 4 - forward
*/

/// <summary>
/// Take a look at the header file for a detailed description of the packetstructure!<br>
/// abstract representation of the sent and received files.
/// Also Comes with static functions to generate Packets of all types.
/// </summary>
class Packet
{
public:
	/// <summary>
	/// Enum of the possible packet types
	/// </summary>
	enum packettype {
		whohas,
		ihave,
		msg,
		ACK,
		forward
	};

	/// <summary>
	/// Map to allow Conversion from packttypes to their corresponding bytevalue
	/// </summary>
	static std::map<packettype, char> type2byte;
	/// <summary>
	/// Map to allow Conversion from a byte value to thei corresponding packettype
	/// </summary>
	static std::map<char, packettype> byte2type;
	
	//packetgenerators:

	/// <summary>
	/// fills a packet with data to create a whohaspacket
	/// </summary>
	/// <param name="p">the packet that is supposed to be filled</param>
	/// <param name="reference">the reference id for this packet</param>
	/// <param name="senderid">the id of the sender of this packet</param>
	/// <param name="max_hops">the maximum amount of hops to the destination</param>
	/// <param name="wanted_client">the id of the wanted client</param>
	static void create_whohas(Packet* p, int reference, int max_hops, int wanted_client);

	/// <summary>
	///	fills a packet with data to create an ihave packet
	/// </summary>
	/// <param name="p">the packet which is supposed to be filled</param>
	/// <param name="max_hops">the maximum amount of hops to the destination</param>
	/// <param name="recipient">the address of the recipient</param>
	/// <param name="reference">the reference id for this packet</param>
	/// <param name="ihavegrid">the ihavegrid containing the network route</param>
	static void create_ihave(Packet* p, int max_hops, int reference, ihave_grid * ihavegrid);

	/// <summary>
	/// fills a packet with data to create an msgpacket
	/// </summary>
	/// <param name="p">the packet thats supposed to be filled</param>
	/// <param name="recipient">the recipients id</param>
	/// <param name="reference">the referenceid for this packet</param>
	/// <param name="route">the route the packets supposed to take containing the original sender and recipient ids</param>
	/// <param name="msgsize">the amount of bytes of the message</param>
	/// <param name="msg">pointer to the messagedata</param>
	static void create_msg(Packet* p, int recipient, int reference, vector<int> route, int msgsize, char* msg);

	/// <summary>
	/// creates an ACK packet that can be sent as an answer to a message using the route the packet took
	/// </summary>
	/// <param name="p">the packet whose data should be filled</param>
	/// <param name="orig_route">the route the original msg packet took</param>
	/// <param name="reference">the reference id of the corresponding msg packet</param>
	static void create_ACK(Packet* p, vector<int> *route, int reference);

	/// <summary>
	/// generates a random integer which can be used
	/// as a reference for packets
	/// </summary>
	/// <returns>random int</returns>
	static int create_reference();


	/// <summary>
	/// initializes an empty packet.
	/// </summary>
	Packet();
	//destructor

	/// <summary>
	/// deallocates the memory allocated by this packet
	/// </summary>
	~Packet();

	//object members:
	
	/// <summary>
	/// type of this packet
	/// </summary>
	packettype type;

	/// <summary>
	/// size in bytes of the raw_data array
	/// </summary>
	int packetsize;

	/// <summary>
	/// the raw data of this packet structured as described above <br>in this headerfile
	/// </summary>
	char* raw_data;

	/// <summary>
	/// the referenceid of this packet
	/// </summary>
	int reference;

	//member-methods:

	/// <summary>
	/// prints the contents of this packet bytewise
	/// </summary>
	void print();
	

private:
	/// <summary>
	/// if the intended route of this packet contains more adresses<br>
	/// than the sender and the recipient, this packet is stacked<br>
	/// in several forwarding packets
	/// </summary>
	/// <param name="route">the route for this packet</param>
	void routepacket(vector<int> route);
};

#endif